% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filter_outliers.R
\name{filter_outliers}
\alias{filter_outliers}
\title{Recursive outlier filtering based on unimodality and multinormality tests}
\usage{
filter_outliers(
  data,
  center,
  test = "Mardia",
  threshold = 0.05,
  distType,
  trimmedPerIteration = 1,
  debug = FALSE,
  warnings = FALSE
)
}
\arguments{
\item{data}{Matrix or Data-Frame of numerical values containing the
observations (rows correspond to observations, columns to variables)}

\item{center}{Coordinates used to computes the distances of the samples and
order them (array of numerical two values, for X and Y)}

\item{test}{Statistical test to use. Valid options are "DIP" for unimodality
test, "Mardia", "Kurtosis", "Skewness", "KS", "KS-adj", "Shapiro",
"Lillie", and "Chisq" for multivariate normality test, or a  or a
user-defined function (see details)}

\item{threshold}{Threshold of significance for the statistical test (between
0 and 1, default: 0.05)}

\item{distType}{Distance metric used to order the samples. Valid options are
"Euclidean", "MCD", "MVE", and "OGK". If empty or NULL, "Euclidean" will be
automatically selected for unimodality tests, and "MCD" for normality tests}

\item{trimmedPerIteration}{Number of samples trimmed at each iteration
(positive integer, default: 1)}

\item{debug}{Logical value. \code{TRUE} will compute all p.values, even after
exceeding the threshold, for plotting purpose (see \code{\link[=plot.BRIC.Filtering]{plot.BRIC.Filtering()}})}

\item{warnings}{Logical value, to display the warnings and errors caught}
}
\value{
The function returns an S3 object of type \code{BRIC.Filtering} containing
the following values: \item{\code{call}}{Parameters of the call (contains
\code{data}, \code{test}, \code{testType}, \code{center}, \code{threshold}, \code{trimmedPerIteration}
and \code{distType})} \item{\code{distances}}{Distances of each sample from \code{data} to
the \code{center} provided} \item{\code{p.values}}{P.Values of the test at each
iteration} \item{\code{index.p.values}}{Subset size corresponding to each
P.Value, for plotting purpose} \item{\code{selected}}{Indices of the samples
from \code{data} selected at the end of the filtering}
\item{\code{cutoffDistance}}{Distance of the furthest inlier selected}
}
\description{
Recursive outlier filtering based on unimodality and multinormality tests
}
\details{
For unimodality tests parameter \code{distType} should be set to
"Euclidean" (as the distribution might contains a large amount of
outliers). For normality tests robust distances are preferable, using a
robust estimate estimates of location and scatter ("MCD","MVE", or "OGK")

For user-defined functions, the function should output the p.value of the
test (between 0 and 1), and receive the 3 following arguments:
\itemize{\item{\code{data}}{ - the matrix of observations} \item{\code{center}}{ -
estimate of the center of the observations} \item{\code{distances}}{ - distances
from each observations to the \code{center} (based on \code{distType} metric)}}
}
\examples{

## Example 1

# Illustrative data
data <- rbind(
  mvtnorm::rmvnorm(300, c(0, 0), diag(2) * 3 - 1),
  mvtnorm::rmvnorm(100, c(15, 20), diag(2)),
  mvtnorm::rmvnorm(150, c(-10, 15), diag(2) * 2 - 0.5),
  mvtnorm::rmvnorm(200, c(5, 5), diag(2) * 200)
)

# Compute an estimate for the center
center <- median_rec(data)$median

# Remove non unimodal outliers from this location
filtering <- filter_outliers(data, center, test = "DIP", debug = TRUE)
print(filtering, maxDisplayed = 200)
plot(filtering)

## Example 2

# Illustrative data
data <- rbind(
  mvtnorm::rmvnorm(300, c(0, 0), diag(2) * 4 - 1.5),
  mvtnorm::rmvnorm(150, c(5, 5), diag(2) * 400)
)

# Compute an estimate for the center
center <- median_rec(data)$median

# Remove non normal outliers from this location
filtering <- filter_outliers(data, center, test = "Chisq", distType = "MVE", debug = TRUE)
print(filtering)
plot(filtering, asp = 1)

## Examples of user-defined tests
\dontrun{

customTest1 <- function(data, center, distances) {
  return(diptest::dip.test(distances)$p.value)
}
filter_outliers(data, center, test = customTest1,
                distType = "Euclidean", debug = TRUE, warnings = TRUE)

customTest2 <- function(data, center, ...) {
  return(stats::ks.test(stats::mahalanobis(data, center, stats::cov(data), tol = 1e-8),
                        "pchisq", df = ncol(data))$p.value)
}
filtering <- filter_outliers(data, center, distType = "Euclidean",
                             test = customTest2, debug = TRUE, warnings = TRUE)

customTest3 <- function(data, ...) {
  return(ICS::mvnorm.skew.test(data)$p.value)
}
filtering <- filter_outliers(data, center, distType = "Euclidean",
                             test = customTest3, threshold = 0.1, debug = TRUE)

}

}
\references{
Adrien Brilhault, Sergio Neuenschwander, and Ricardo Rios - A New
Robust Multivariate Mode Estimator for Eye-tracking Calibration - Behavior
Research Methods, 2022 - \href{https://rdcu.be/cI9Pf}{rdcu.be/cI9Pf}
}
\seealso{
\code{\link[=plot.BRIC.Filtering]{plot.BRIC.Filtering()}}, \code{\link[=print.BRIC.Filtering]{print.BRIC.Filtering()}}, \code{\link[=clustBRIC]{clustBRIC()}},
\code{\link[=median_rec]{median_rec()}}, \code{\link[=median_mv]{median_mv()}}, \code{\link[=depth_values]{depth_values()}}
}
