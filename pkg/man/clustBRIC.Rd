% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clustBRIC.R
\name{clustBRIC}
\alias{clustBRIC}
\title{Bootstrap and Refine Iterative Clustering}
\usage{
clustBRIC(
  data,
  maxIterations = 0,
  minUnassigned = 0.1,
  nsamp = "best",
  method = "Projection",
  alpha = 0.5,
  testUnimodal = "DIP",
  threshUnimodal = 0.05,
  distUnimodal = "Euclidean",
  testNormal = "Mardia",
  threshNormal = 0.05,
  distNormal = "MCD",
  trimmedPerFilteringIteration = 1,
  debug = FALSE,
  warnings = FALSE
)
}
\arguments{
\item{data}{Matrix or Data-Frame of numerical values containing the
observations (rows correspond to observations, columns to variables)}

\item{maxIterations}{Maximum number of iterations performed by the algorithm
(i.e. max number of potential clusters encountered). Set to NULL or 0 for
unlimited number (default)}

\item{minUnassigned}{Numerical value between 0 and 1 (default: 0.1),
providing the proportion of unassigned samples from \code{data} under which the
algorithm will terminate the search}

\item{nsamp}{Number of samples randomly selected from \code{data} for subsampling
calculations, or "best", "exact" or "sample". If "sample" is chosen, the
subset will include up to 2000 observations; with "best" up to 4000
(default); with "exact" (or 0), exhaustive search will be attempted on the
complete dataset (computation in this case might take a long time). When
subsampling, the remaining observations will be assigned to the cluster of
their closest neighbor.}

\item{method}{Method to use. Valid options are "MCD" and "MVE" for convex
body minimizers, or "L2", "Lui", "Mahalanobis", "Oja", "Projection"
(default), "Spatial" and "Tukey" for depth functions}

\item{alpha}{Proportion of samples trimmed at each iteration of the recursive
median estimate (numerical value between 0 and 1, default: 0.5), see
\code{\link[=median_rec]{median_rec()}}}

\item{testUnimodal}{Statistical test used for unimodality. Valid options are
"DIP" or a user-defined function (see \code{\link[=filter_outliers]{filter_outliers()}})}

\item{threshUnimodal}{Threshold of significance for the unimodality test
(numerical value between 0 and 1, default: 0.05)}

\item{distUnimodal}{Distance metric used for ordering the samples in the
unimodal filtering. Valid options are "Euclidean" (default), or "MCD",
"MVE", and "OGK" for robust distances. "Euclidean" is strongly advised for
unimodality tests.}

\item{testNormal}{Statistical test used for normality. Valid options are
"Mardia" (default), "Kurtosis", "Skewness", "KS", "KS-adj", "Shapiro",
"Lillie", "Chisq", or a user-defined function (see \code{\link[=filter_outliers]{filter_outliers()}})}

\item{threshNormal}{Threshold of significance for the normality test
(numerical value between 0 and 1, default: 0.05)}

\item{distNormal}{Distance metric used for ordering the samples in the normal
filtering. Valid options are "Euclidean", or "MCD" (default), "MVE", and
"OGK" for robust distances. Robust distances are strongly advised for
normality tests.}

\item{trimmedPerFilteringIteration}{Number of samples trimmed at each
iteration of the unimodality and normality filtering (default: 1), see
\code{\link[=filter_outliers]{filter_outliers()}}}

\item{debug}{Logical value. \code{TRUE} will compute all p.values in the filtering
steps (even after they exceed the selection threshold, see
\code{\link[=plot.BRIC.Filtering]{plot.BRIC.Filtering()}})}

\item{warnings}{Logical value, to display the warnings and errors caught}
}
\value{
The function returns an S3 object of type \code{BRIC} containing the
following values:
\item{\code{call}}{Parameters of the call (contains \code{data},
\code{maxIterations}, \code{minUnassigned}, \code{nsamp}, \code{method}, \code{alpha}, \code{testUnimodal},
\code{threshUnimodal}, \code{distUnimodal}, \code{testNormal}, \code{threshNormal},
\code{distNormal}, and \code{trimmedPerFilteringIteration})}
\item{\code{iterations}}{A list with every global iteration of the algorithm,
each containing the two filtering procedures performed: \code{filteringUnimodal}
and \code{filteringNormal} (both being S3 object of class \code{BRIC.Filtering}, see
\code{\link[=filter_outliers]{filter_outliers()}})}
\item{\code{nbClusters}}{Number of groups encountered}
\item{\code{labels}}{Labels of the groups encountered (corresponding to the
number of the iteration they were identified in)}
\item{\code{clustersCenters}}{Matrix containing the coordinates of the centers
of each group (row-wise)}
\item{\code{clustersSizes}}{Array with the number of
samples in each group}
\item{\code{mainCluster}}{Index of the group identified as main mode}
}
\description{
Robust clustering algorithm based on depth measures and convex body
minimizers
}
\examples{

# Create a sample distribution and run clustBRIC() function
data <- rbind(
  mvtnorm::rmvnorm(300, c(0, 0), diag(2) * 3 - 1),
  mvtnorm::rmvnorm(100, c(15, 20), diag(2)),
  mvtnorm::rmvnorm(150, c(-10, 15), diag(2) * 2 - 0.5),
  mvtnorm::rmvnorm(200, c(5, 5), diag(2) * 200)
)

res <- clustBRIC(data, debug = TRUE)
print(res)

# Plot the mode and groups encountered
plot(res)

# Plot the different iterations (interactive)
\dontrun{
plot(res, contents = "iterations", asp = 1)
}

# See ?plot.BRIC() for other plotting examples

}
\references{
Adrien Brilhault, Sergio Neuenschwander, and Ricardo Rios - A New
Robust Multivariate Mode Estimator for Eye-tracking Calibration - Behavior
Research Methods, 2022 - \href{https://rdcu.be/cI9Pf}{rdcu.be/cI9Pf}
}
\seealso{
\code{\link[=plot.BRIC]{plot.BRIC()}}, \code{\link[=print.BRIC]{print.BRIC()}}, \code{\link[=filter_outliers]{filter_outliers()}}, \code{\link[=median_rec]{median_rec()}},
\code{\link[=median_mv]{median_mv()}}, \code{\link[=depth_values]{depth_values()}}
}
